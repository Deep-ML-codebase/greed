"use strict";(this.webpackChunkGreed=this.webpackChunkGreed||[]).push([[867],{867:(e,n,t)=>{function s(){return'\n# WebGPU-enabled PyTorch polyfill setup\nimport numpy as np\nimport sys\n\nclass WebGPUDevice:\n    def __init__(self, device_type):\n        self.type = device_type\n        \n    def __str__(self):\n        return self.type\n        \n    def __repr__(self):\n        return f"device(type=\'{self.type}\')"\n\nclass WebGPUTensor:\n    def __init__(self, data, device=\'cpu\', dtype=\'float32\', requires_grad=False, _force_webgpu=False):\n        if isinstance(data, (list, tuple)):\n            self.data = np.array(data, dtype=dtype)\n        elif isinstance(data, np.ndarray):\n            self.data = data.astype(dtype)\n        else:\n            self.data = np.array(data, dtype=dtype)\n        \n        # Determine actual device based on tensor size and WebGPU availability\n        self._original_device = device\n        self._force_webgpu = _force_webgpu\n        \n        # TEMPORARILY DISABLED: Auto-detect WebGPU to prevent recursion\n        # Auto-detect WebGPU usage for larger tensors or when forced\n        # if (_force_webgpu or self._should_use_webgpu(data)) and device != \'cpu\':\n        #     self.device = WebGPUDevice(\'webgpu\')\n        # elif device == \'cuda\' or device == \'gpu\':\n        #     # Map CUDA/GPU requests to WebGPU if available\n        #     self.device = WebGPUDevice(\'webgpu\')\n        # else:\n        #     self.device = WebGPUDevice(device) if isinstance(device, str) else device\n\n        # Simple device assignment to prevent recursion\n        self.device = device\n        \n        self.dtype = dtype\n        self.requires_grad = requires_grad\n        self.shape = self.data.shape\n        self.ndim = self.data.ndim\n        self.grad = None\n        self.grad_fn = None\n    \n    def size(self, dim=None):\n        """Return the size of the tensor or a specific dimension"""\n        if dim is None:\n            return self.shape\n        else:\n            if dim < 0:\n                dim = self.ndim + dim\n            if dim >= self.ndim or dim < 0:\n                raise IndexError(f"Dimension out of range (expected to be in range of [{-self.ndim}, {self.ndim-1}], but got {dim})")\n            return self.shape[dim]\n    \n    def _should_use_webgpu(self, data):\n        """Determine if WebGPU should be used based on tensor characteristics"""\n        try:\n            # Use WebGPU for tensors with more than 1 element (very low threshold)\n            if hasattr(data, \'size\'):\n                return data.size > 1\n            elif hasattr(data, \'__len__\'):\n                return len(data) > 1\n            return False\n        except:\n            return False\n        \n    def numpy(self):\n        return self.data\n        \n    def tolist(self):\n        return self.data.tolist()\n\n    def item(self):\n        """Return the value of this tensor as a standard Python number"""\n        if self.data.size == 1:\n            value = self.data.item()\n            # Ensure we return proper Python types that can be used as indices\n            if self.dtype in [\'int32\', \'int64\', \'long\']:\n                return int(value)\n            elif self.dtype in [\'float32\', \'float64\', \'double\']:\n                return float(value)\n            else:\n                # For other types, try to convert appropriately\n                if isinstance(value, (int, np.integer)):\n                    return int(value)\n                elif isinstance(value, (float, np.floating)):\n                    return float(value)\n                else:\n                    return value\n        else:\n            raise ValueError("only one element tensors can be converted to Python scalars")\n\n    def __format__(self, format_spec):\n        """Support for f-string formatting"""\n        if self.data.size == 1:\n            return format(self.data.item(), format_spec)\n        else:\n            return format(str(self), format_spec)\n\n    def view(self, *shape):\n        """Reshape tensor maintaining data"""\n        if len(shape) == 1 and isinstance(shape[0], (list, tuple)):\n            shape = shape[0]\n        \n        # Handle -1 for automatic size calculation\n        if -1 in shape:\n            total_size = self.data.size\n            known_size = 1\n            unknown_idx = -1\n            for i, s in enumerate(shape):\n                if s == -1:\n                    unknown_idx = i\n                else:\n                    known_size *= s\n            if unknown_idx != -1:\n                shape = list(shape)\n                shape[unknown_idx] = total_size // known_size\n                shape = tuple(shape)\n        \n        reshaped_data = self.data.reshape(shape)\n        return WebGPUTensor(reshaped_data, device="webgpu", dtype=self.dtype, requires_grad=self.requires_grad)\n    \n    def reshape(self, *shape):\n        return self.view(*shape)\n    \n    def transpose(self, dim0, dim1):\n        transposed_data = np.swapaxes(self.data, dim0, dim1)\n        return WebGPUTensor(transposed_data, device="webgpu", dtype=self.dtype, requires_grad=self.requires_grad)\n\n    def unsqueeze(self, dim):\n        """Add a dimension of size 1"""\n        new_shape = list(self.data.shape)\n        if dim < 0:\n            dim = len(new_shape) + dim + 1\n        new_shape.insert(dim, 1)\n        reshaped_data = self.data.reshape(new_shape)\n        return WebGPUTensor(reshaped_data, device="webgpu", dtype=self.dtype, requires_grad=self.requires_grad)\n\n    def flatten(self, start_dim=0, end_dim=-1):\n        """Flatten tensor dimensions"""\n        if end_dim == -1:\n            end_dim = self.data.ndim - 1\n\n        shape = list(self.data.shape)\n        flattened_size = 1\n        for i in range(start_dim, end_dim + 1):\n            flattened_size *= shape[i]\n\n        new_shape = shape[:start_dim] + [flattened_size] + shape[end_dim + 1:]\n        flattened_data = self.data.reshape(new_shape)\n        return WebGPUTensor(flattened_data, device="webgpu", dtype=self.dtype, requires_grad=self.requires_grad)\n\n    def squeeze(self, dim=None):\n        """Remove dimensions of size 1"""\n        if dim is None:\n            # Remove all dimensions of size 1\n            squeezed_data = np.squeeze(self.data)\n        else:\n            # Remove specific dimension if it has size 1\n            if dim < 0:\n                dim = self.data.ndim + dim\n            if self.data.shape[dim] != 1:\n                return self  # No change if dimension is not size 1\n            squeezed_data = np.squeeze(self.data, axis=dim)\n\n        return WebGPUTensor(squeezed_data, device="webgpu", dtype=self.dtype, requires_grad=self.requires_grad)\n\n    def sum(self, dim=None, keepdim=False):\n        if dim is None:\n            result_data = np.sum(self.data)\n        else:\n            result_data = np.sum(self.data, axis=dim, keepdims=keepdim)\n        result = WebGPUTensor(result_data, device="webgpu", dtype=self.dtype, requires_grad=self.requires_grad)\n\n        # Autograd disabled for stability - backward functions removed\n\n        return result\n    \n    def mean(self, dim=None, keepdim=False):\n        if dim is None:\n            result_data = np.mean(self.data)\n        else:\n            result_data = np.mean(self.data, axis=dim, keepdims=keepdim)\n        return WebGPUTensor(result_data, device="webgpu", dtype=self.dtype, requires_grad=self.requires_grad)\n    \n    def std(self, dim=None, keepdim=False, unbiased=True):\n        """Compute standard deviation"""\n        if dim is None:\n            result_data = np.std(self.data, ddof=1 if unbiased else 0)\n        else:\n            result_data = np.std(self.data, axis=dim, keepdims=keepdim, ddof=1 if unbiased else 0)\n        return WebGPUTensor(result_data, device="webgpu", dtype=self.dtype, requires_grad=self.requires_grad)\n    \n    def var(self, dim=None, keepdim=False, unbiased=True):\n        """Compute variance"""\n        if dim is None:\n            result_data = np.var(self.data, ddof=1 if unbiased else 0)\n        else:\n            result_data = np.var(self.data, axis=dim, keepdims=keepdim, ddof=1 if unbiased else 0)\n        return WebGPUTensor(result_data, device="webgpu", dtype=self.dtype, requires_grad=self.requires_grad)\n    \n    def to(self, device):\n        new_device = WebGPUDevice(device) if isinstance(device, str) else device\n        return WebGPUTensor(self.data.copy(), device=new_device, dtype=self.dtype, requires_grad=self.requires_grad)\n    \n    def cpu(self):\n        return self.to(\'cpu\')\n    \n    def cuda(self):\n        return self.to(\'cuda\')\n        \n    def __repr__(self):\n        return f"tensor({self.data}, device=\'{self.device}\', dtype=\'{self.dtype}\')"\n    \n    def __float__(self):\n        """Convert single-element tensor to Python float"""\n        if self.data.size == 1:\n            return float(self.data.item())\n        else:\n            raise TypeError(f"only single-element tensors can be converted to Python scalars")\n    \n    def __int__(self):\n        """Convert single-element tensor to Python int"""\n        if self.data.size == 1:\n            return int(self.data.item())\n        else:\n            raise TypeError(f"only single-element tensors can be converted to Python scalars")\n\n    def __len__(self):\n        """Return the length of the first dimension"""\n        if self.ndim == 0:\n            raise TypeError("len() of unsized object")\n        return self.shape[0]\n\n    def __getitem__(self, key):\n        """Support tensor indexing like tensor[indices]"""\n        if isinstance(key, WebGPUTensor):\n            # Convert WebGPUTensor indices to numpy array\n            indices = key.data.astype(int)\n            result_data = self.data[indices]\n        else:\n            result_data = self.data[key]\n        \n        return WebGPUTensor(result_data, device="webgpu", dtype=self.dtype, requires_grad=self.requires_grad)\n    \n    def __setitem__(self, key, value):\n        """Support tensor item assignment like tensor[indices] = value"""\n        if isinstance(value, WebGPUTensor):\n            value_data = value.data\n        else:\n            value_data = value\n\n        if isinstance(key, WebGPUTensor):\n            # Convert WebGPUTensor indices to numpy array\n            indices = key.data.astype(int)\n            self.data[indices] = value_data\n        else:\n            self.data[key] = value_data\n    \n    # Comparison operators\n    def __eq__(self, other):\n        """Element-wise equality comparison"""\n        if isinstance(other, WebGPUTensor):\n            result_data = self.data == other.data\n        else:\n            result_data = self.data == other\n        return WebGPUTensor(result_data, device="webgpu", dtype=\'bool\')\n\n    def __ne__(self, other):\n        """Element-wise not-equal comparison"""\n        if isinstance(other, WebGPUTensor):\n            result_data = self.data != other.data\n        else:\n            result_data = self.data != other\n        return WebGPUTensor(result_data, device="webgpu", dtype=\'bool\')\n    \n    def __gt__(self, other):\n        """Element-wise greater than comparison"""\n        if isinstance(other, WebGPUTensor):\n            result_data = self.data > other.data\n        else:\n            result_data = self.data > other\n        return WebGPUTensor(result_data, device="webgpu", dtype=\'bool\')\n\n    def __lt__(self, other):\n        """Element-wise less than comparison"""\n        if isinstance(other, WebGPUTensor):\n            result_data = self.data < other.data\n        else:\n            result_data = self.data < other\n        return WebGPUTensor(result_data, device="webgpu", dtype=\'bool\')\n\n    def __ge__(self, other):\n        """Element-wise greater than or equal comparison"""\n        if isinstance(other, WebGPUTensor):\n            result_data = self.data >= other.data\n        else:\n            result_data = self.data >= other\n        return WebGPUTensor(result_data, device="webgpu", dtype=\'bool\')\n\n    def __le__(self, other):\n        """Element-wise less than or equal comparison"""\n        if isinstance(other, WebGPUTensor):\n            result_data = self.data <= other.data\n        else:\n            result_data = self.data <= other\n        return WebGPUTensor(result_data, device="webgpu", dtype=\'bool\')\n\n    # Arithmetic operators\n    def __add__(self, other):\n        if isinstance(other, WebGPUTensor):\n            result_data = self.data + other.data\n        else:\n            result_data = self.data + other\n\n        result = WebGPUTensor(result_data, device="webgpu", dtype=self.dtype,\n                             requires_grad=self.requires_grad or (isinstance(other, WebGPUTensor) and other.requires_grad))\n\n        # Autograd disabled for stability - backward functions removed\n\n        return result\n    \n    def __sub__(self, other):\n        if isinstance(other, WebGPUTensor):\n            result_data = self.data - other.data\n        else:\n            result_data = self.data - other\n        return WebGPUTensor(result_data, device="webgpu", dtype=self.dtype, requires_grad=self.requires_grad)\n    \n    def __mul__(self, other):\n        if isinstance(other, WebGPUTensor):\n            result_data = self.data * other.data\n        else:\n            result_data = self.data * other\n\n        result = WebGPUTensor(result_data, device="webgpu", dtype=self.dtype,\n                             requires_grad=self.requires_grad or (isinstance(other, WebGPUTensor) and other.requires_grad))\n\n        # Autograd disabled for stability - backward functions removed\n\n        return result\n    \n    def __truediv__(self, other):\n        if isinstance(other, WebGPUTensor):\n            result_data = self.data / other.data\n        else:\n            result_data = self.data / other\n        return WebGPUTensor(result_data, device="webgpu", dtype=self.dtype, requires_grad=self.requires_grad)\n\n    def __pow__(self, other):\n        if isinstance(other, WebGPUTensor):\n            result_data = np.power(self.data, other.data)\n        else:\n            result_data = np.power(self.data, other)\n\n        result = WebGPUTensor(result_data, device="webgpu", dtype=self.dtype,\n                             requires_grad=self.requires_grad or (isinstance(other, WebGPUTensor) and other.requires_grad))\n\n        # Autograd disabled for stability - backward functions removed\n\n        return result\n    \n    def __radd__(self, other):\n        result_data = other + self.data\n        result = WebGPUTensor(result_data, device="webgpu", dtype=self.dtype, requires_grad=self.requires_grad)\n\n        # Autograd disabled for stability - backward functions removed\n\n        return result\n    \n    def __rmul__(self, other):\n        result_data = other * self.data\n        result = WebGPUTensor(result_data, device="webgpu", dtype=self.dtype, requires_grad=self.requires_grad)\n\n        # Autograd disabled for stability - backward functions removed\n\n        return result\n\n    def __rsub__(self, other):\n        result_data = other - self.data\n        result = WebGPUTensor(result_data, device="webgpu", dtype=self.dtype, requires_grad=self.requires_grad)\n\n        # Autograd disabled for stability - backward functions removed\n\n        return result\n\n    def __rtruediv__(self, other):\n        result_data = other / self.data\n        result = WebGPUTensor(result_data, device="webgpu", dtype=self.dtype, requires_grad=self.requires_grad)\n\n        # Autograd disabled for stability - backward functions removed\n\n        return result\n\n    def __rpow__(self, other):\n        result_data = np.power(other, self.data)\n        result = WebGPUTensor(result_data, device="webgpu", dtype=self.dtype, requires_grad=self.requires_grad)\n\n        # Autograd disabled for stability - backward functions removed\n\n        return result\n    \n    def __matmul__(self, other):\n        """Matrix multiplication operator (@)"""\n        if isinstance(other, WebGPUTensor):\n            if self.ndim == 2 and other.ndim == 2:\n                result_data = np.dot(self.data, other.data)\n            elif self.ndim == 1 and other.ndim == 2:\n                result_data = np.dot(self.data, other.data)\n            elif self.ndim == 2 and other.ndim == 1:\n                result_data = np.dot(self.data, other.data)\n            else:\n                result_data = np.matmul(self.data, other.data)\n        else:\n            result_data = np.matmul(self.data, other)\n        \n        result = WebGPUTensor(result_data, device="webgpu", dtype=self.dtype,\n                             requires_grad=self.requires_grad or (isinstance(other, WebGPUTensor) and other.requires_grad))\n\n        # Autograd disabled for stability - backward functions removed\n        \n        return result\n    \n    def __rmatmul__(self, other):\n        """Reverse matrix multiplication"""\n        result_data = np.matmul(other, self.data)\n        return WebGPUTensor(result_data, device="webgpu", dtype=self.dtype, requires_grad=self.requires_grad)\n    \n    def retain_grad(self):\n        """Enable gradient retention for non-leaf tensor"""\n        if not self.requires_grad:\n            raise RuntimeError("can\'t retain_grad on Tensor that has requires_grad=False")\n        self._retain_grad = True\n        return self\n    \n    def zero_grad(self):\n        """Zero out the gradients"""\n        if self.grad is not None:\n            self.grad.data.fill(0)\n\n    def backward(self, gradient=None, retain_graph=False, create_graph=False):\n        """Placeholder backward method - autograd disabled for stability"""\n        if not self.requires_grad:\n            return\n\n        # For now, just initialize a dummy gradient to prevent errors\n        # Real autograd implementation will be added later\n        if self.grad is None:\n            self.grad = WebGPUTensor(np.zeros_like(self.data), device="webgpu", dtype=self.dtype)\n\n        print("Note: Autograd is currently disabled. Gradient computation skipped.")\n    \n    def _matmul_backward(self, grad_output, other):\n        """Backward pass for matrix multiplication"""\n        if isinstance(other, WebGPUTensor):\n            # d/da (a @ b) = grad_output @ b.T\n            if self.grad is None:\n                self.grad = WebGPUTensor(np.zeros_like(self.data), device="webgpu", dtype=self.dtype)\n            self_grad = np.matmul(grad_output.data, other.data.T)\n            self.grad.data += self_grad\n            \n            # d/db (a @ b) = a.T @ grad_output  \n            if other.requires_grad:\n                if other.grad is None:\n                    other.grad = WebGPUTensor(np.zeros_like(other.data), device="webgpu", dtype=other.dtype)\n                other_grad = np.matmul(self.data.T, grad_output.data)\n                other.grad.data += other_grad\n\n# Linear algebra operations module\nclass TorchLinalg:\n    """Linear algebra operations module"""\n    \n    def __init__(self):\n        pass\n    \n    def det(self, input_tensor):\n        """Compute determinant"""\n        if isinstance(input_tensor, WebGPUTensor):\n            if input_tensor.ndim != 2 or input_tensor.shape[0] != input_tensor.shape[1]:\n                raise RuntimeError("linalg.det() expects a 2D square tensor")\n            det_value = np.linalg.det(input_tensor.data.reshape(input_tensor.shape))\n            return WebGPUTensor([det_value], device="webgpu", dtype=input_tensor.dtype)\n        else:\n            return np.linalg.det(input_tensor)\n    \n    def inv(self, input_tensor):\n        """Compute matrix inverse"""\n        if isinstance(input_tensor, WebGPUTensor):\n            if input_tensor.ndim != 2 or input_tensor.shape[0] != input_tensor.shape[1]:\n                raise RuntimeError("linalg.inv() expects a 2D square tensor")\n            inv_data = np.linalg.inv(input_tensor.data.reshape(input_tensor.shape))\n            return WebGPUTensor(inv_data, device="webgpu", dtype=input_tensor.dtype)\n        else:\n            return np.linalg.inv(input_tensor)\n    \n    def norm(self, input_tensor, ord=None, dim=None, keepdim=False):\n        """Compute matrix or vector norm"""\n        if isinstance(input_tensor, WebGPUTensor):\n            if dim is None:\n                norm_value = np.linalg.norm(input_tensor.data, ord=ord)\n                return WebGPUTensor([norm_value], device="webgpu", dtype=input_tensor.dtype)\n            else:\n                norm_data = np.linalg.norm(input_tensor.data.reshape(input_tensor.shape), ord=ord, axis=dim, keepdims=keepdim)\n                return WebGPUTensor(norm_data, device="webgpu", dtype=input_tensor.dtype)\n        else:\n            return np.linalg.norm(input_tensor, ord=ord, axis=dim, keepdims=keepdim)\n    \n    def eig(self, input_tensor):\n        """Compute eigenvalues and eigenvectors"""\n        if isinstance(input_tensor, WebGPUTensor):\n            if input_tensor.ndim != 2 or input_tensor.shape[0] != input_tensor.shape[1]:\n                raise RuntimeError("linalg.eig() expects a 2D square tensor")\n            eigenvalues, eigenvectors = np.linalg.eig(input_tensor.data.reshape(input_tensor.shape))\n            return (\n                WebGPUTensor(eigenvalues, device="webgpu", dtype=input_tensor.dtype),\n                WebGPUTensor(eigenvectors, device="webgpu", dtype=input_tensor.dtype)\n            )\n        else:\n            return np.linalg.eig(input_tensor)\n    \n    def svd(self, input_tensor, full_matrices=True):\n        """Compute singular value decomposition"""\n        if isinstance(input_tensor, WebGPUTensor):\n            U, S, Vh = np.linalg.svd(input_tensor.data.reshape(input_tensor.shape), full_matrices=full_matrices)\n            return (\n                WebGPUTensor(U, device="webgpu", dtype=input_tensor.dtype),\n                WebGPUTensor(S, device="webgpu", dtype=input_tensor.dtype),\n                WebGPUTensor(Vh, device="webgpu", dtype=input_tensor.dtype)\n            )\n        else:\n            return np.linalg.svd(input_tensor, full_matrices=full_matrices)\n\n# Neural network functional operations\nclass TorchNNFunctional:\n    @staticmethod\n    def relu(input_tensor):\n        if isinstance(input_tensor, WebGPUTensor):\n            result_data = np.maximum(input_tensor.data, 0)\n            return WebGPUTensor(result_data, device="webgpu", dtype=input_tensor.dtype)\n        else:\n            return np.maximum(input_tensor, 0)\n    \n    @staticmethod\n    def sigmoid(input_tensor):\n        if isinstance(input_tensor, WebGPUTensor):\n            result_data = 1 / (1 + np.exp(-input_tensor.data))\n            return WebGPUTensor(result_data, device="webgpu", dtype=input_tensor.dtype)\n        else:\n            return 1 / (1 + np.exp(-input_tensor))\n\n# Neural network modules\nclass TorchNNModule:\n    def __init__(self):\n        self._parameters = {}\n        self._modules = {}\n        self._buffers = {}\n        self._non_persistent_buffers_set = set()\n        self._backward_hooks = {}\n        self._backward_pre_hooks = {}\n        self._forward_hooks = {}\n        self._forward_pre_hooks = {}\n        self._state_dict_hooks = {}\n        self._load_state_dict_pre_hooks = {}\n        self.training = True\n        \n    def parameters(self):\n        params = []\n        for param in self._parameters.values():\n            params.append(param)\n        for module in self._modules.values():\n            if hasattr(module, \'parameters\'):\n                params.extend(module.parameters())\n        return params\n    \n    def __call__(self, *args, **kwargs):\n        return self.forward(*args, **kwargs)\n    \n    def forward(self, x):\n        raise NotImplementedError\n\nclass TorchNNLinear(TorchNNModule):\n    def __init__(self, in_features, out_features, bias=True):\n        self._parameters = {}\n        self._modules = {}\n        self._buffers = {}\n        self._non_persistent_buffers_set = set()\n        self._backward_hooks = {}\n        self._backward_pre_hooks = {}\n        self._forward_hooks = {}\n        self._forward_pre_hooks = {}\n        self._state_dict_hooks = {}\n        self._load_state_dict_pre_hooks = {}\n        self.training = True\n        self.in_features = in_features\n        self.out_features = out_features\n        \n        weight_data = np.random.randn(out_features, in_features) * np.sqrt(2.0 / in_features)\n        self.weight = WebGPUTensor(weight_data, requires_grad=True)\n        self._parameters[\'weight\'] = self.weight\n        \n        if bias:\n            bias_data = np.zeros(out_features)\n            self.bias = WebGPUTensor(bias_data, requires_grad=True)\n            self._parameters[\'bias\'] = self.bias\n        else:\n            self.bias = None\n    \n    def forward(self, x):\n        if isinstance(x, WebGPUTensor):\n            result = WebGPUTensor(np.dot(x.data, self.weight.data.T), device="webgpu", dtype=x.dtype)\n            if self.bias is not None:\n                result.data = result.data + self.bias.data\n            return result\n        else:\n            raise TypeError("Input must be WebGPUTensor")\n\nclass TorchNNReLU(TorchNNModule):\n    def __init__(self):\n        self._parameters = {}\n        self._modules = {}\n        self._buffers = {}\n        self._non_persistent_buffers_set = set()\n        self._backward_hooks = {}\n        self._backward_pre_hooks = {}\n        self._forward_hooks = {}\n        self._forward_pre_hooks = {}\n        self._state_dict_hooks = {}\n        self._load_state_dict_pre_hooks = {}\n        self.training = True\n\n    def forward(self, x):\n        if isinstance(x, WebGPUTensor):\n            result_data = np.maximum(x.data, 0)\n            return WebGPUTensor(result_data, device="webgpu", dtype=x.dtype, requires_grad=x.requires_grad)\n        else:\n            return np.maximum(x, 0)\n\nclass TorchNNMSELoss(TorchNNModule):\n    def __init__(self, reduction=\'mean\'):\n        self._parameters = {}\n        self._modules = {}\n        self._buffers = {}\n        self._non_persistent_buffers_set = set()\n        self._backward_hooks = {}\n        self._backward_pre_hooks = {}\n        self._forward_hooks = {}\n        self._forward_pre_hooks = {}\n        self._state_dict_hooks = {}\n        self._load_state_dict_pre_hooks = {}\n        self.training = True\n        self.reduction = reduction\n\n    def forward(self, input_tensor, target_tensor):\n        if isinstance(input_tensor, WebGPUTensor) and isinstance(target_tensor, WebGPUTensor):\n            diff = input_tensor.data - target_tensor.data\n            squared_error = diff ** 2\n\n            if self.reduction == \'mean\':\n                loss_value = np.mean(squared_error)\n            elif self.reduction == \'sum\':\n                loss_value = np.sum(squared_error)\n            else:  # \'none\'\n                loss_value = squared_error\n\n            return WebGPUTensor([loss_value] if np.isscalar(loss_value) else loss_value,\n                             device="webgpu", dtype=input_tensor.dtype)\n        else:\n            raise TypeError("Both input and target must be WebGPUTensor")\n\n# Create torch module with essential functions\nclass TorchModule:\n    def __init__(self):\n        self.tensor = self._tensor\n        self.zeros = self._zeros\n        self.ones = self._ones\n        self.randn = self._randn\n        self.zeros_like = self._zeros_like\n        self.matmul = self._matmul\n        self.sum = self._sum\n        self.as_tensor = self._as_tensor\n        self.arange = self._arange\n        self.randperm = self._randperm\n        self.linspace = self._linspace\n        self.nn = TorchNN()\n\n        # Add Tensor class reference\n        self.Tensor = WebGPUTensor\n\n        # Linear algebra module\n        self.linalg = TorchLinalg()\n\n        # Activation functions\n        self.relu = self._relu\n\n        # Mathematical functions\n        self.round = self.round\n        self.sqrt = self._sqrt\n        self.pow = self._pow\n        self.exp = self._exp\n        self.log = self._log\n        self.mean = self._mean\n        self.max = self._max\n        self.min = self._min\n        self.transpose = self._transpose\n\n        # Advanced mathematical functions\n        self.cat = self._cat\n        self.stack = self._stack\n        self.std = self._std\n        self.abs = self._abs\n        self.sin = self._sin\n        self.cos = self._cos\n        self.clamp = self._clamp\n        self.argmax = self._argmax\n\n        # Context managers\n        self.no_grad = self._no_grad\n\n        # Data types\n        self.float32 = \'float32\'\n        self.float64 = \'float64\'\n        self.double = \'float64\'\n        self.float = \'float32\'\n        self.int32 = \'int32\'\n        self.int64 = \'int64\'\n        self.long = \'int64\'\n        self.int = \'int32\'\n        self.bool = \'bool\'\n        self.uint8 = \'uint8\'\n        \n        # Device types\n        # self.device = self._device  # DISABLED: Potential recursion source\n        \n    def _tensor(self, data, **kwargs):\n        # Enable WebGPU detection by default for tensor creation\n        if \'device\' not in kwargs:\n            kwargs[\'device\'] = \'webgpu\'  # Default to WebGPU instead of CPU\n        return WebGPUTensor(data, **kwargs)\n    \n    def _zeros(self, *shape, **kwargs):\n        data = np.zeros(shape)\n        return WebGPUTensor(data, **kwargs)\n    \n    def _ones(self, *shape, **kwargs):\n        data = np.ones(shape)\n        return WebGPUTensor(data, **kwargs)\n    \n    def _randn(self, *shape, **kwargs):\n        data = np.random.randn(*shape)\n        return WebGPUTensor(data, **kwargs)\n    \n    def _matmul(self, a, b):\n        if isinstance(a, WebGPUTensor) and isinstance(b, WebGPUTensor):\n            return WebGPUTensor(np.dot(a.data, b.data), device="webgpu")\n        return WebGPUTensor(np.dot(a, b))\n    \n    def _device(self, device_type):\n        """Create a device object"""\n        return WebGPUDevice(device_type)\n    \n    def _sum(self, input_tensor, dim=None, keepdim=False, dtype=None):\n        """Compute sum of tensor elements"""\n        if isinstance(input_tensor, WebGPUTensor):\n            return input_tensor.sum(dim=dim, keepdim=keepdim)\n        else:\n            # Handle numpy arrays or lists\n            if dim is None:\n                result_data = np.sum(input_tensor)\n            else:\n                result_data = np.sum(input_tensor, axis=dim, keepdims=keepdim)\n            return WebGPUTensor(result_data, dtype=dtype or \'float32\')\n    \n    def _as_tensor(self, data, dtype=None, device=None):\n        """Convert data to tensor, similar to torch.as_tensor"""\n        # Determine dtype\n        if dtype is None:\n            if hasattr(data, \'dtype\'):\n                dtype = str(data.dtype)\n            else:\n                dtype = \'float32\'\n        \n        # Determine device - default to WebGPU for better performance\n        if device is None:\n            device = \'webgpu\'\n        \n        # Create tensor\n        return WebGPUTensor(data, dtype=dtype, device=device)\n    \n    def eye(self, n, m=None, dtype=\'float32\', device=\'webgpu\'):\n        """Create identity matrix"""\n        if m is None:\n            m = n\n        data = np.eye(n, m)\n        return WebGPUTensor(data, device=device, dtype=dtype)\n    \n    def round(self, input_tensor, decimals=0):\n        """Round tensor elements to given number of decimals"""\n        if isinstance(input_tensor, WebGPUTensor):\n            rounded_data = np.round(input_tensor.data, decimals=decimals)\n            return WebGPUTensor(rounded_data, device="webgpu", dtype=input_tensor.dtype, requires_grad=input_tensor.requires_grad)\n        else:\n            return WebGPUTensor(np.round(input_tensor, decimals=decimals))\n    \n    def det(self, input_tensor):\n        """Compute determinant of square matrix"""\n        if isinstance(input_tensor, WebGPUTensor):\n            if input_tensor.ndim != 2 or input_tensor.shape[0] != input_tensor.shape[1]:\n                raise RuntimeError("det() expects a 2D square tensor")\n            det_value = np.linalg.det(input_tensor.data.reshape(input_tensor.shape))\n            return WebGPUTensor([det_value], device="webgpu", dtype=input_tensor.dtype)\n        else:\n            return np.linalg.det(input_tensor)\n    \n    def _arange(self, *args, **kwargs):\n        """Create a 1D tensor with evenly spaced values"""\n        if len(args) == 1:\n            # arange(end)\n            start, end, step = 0, args[0], 1\n        elif len(args) == 2:\n            # arange(start, end)\n            start, end, step = args[0], args[1], 1\n        elif len(args) == 3:\n            # arange(start, end, step)\n            start, end, step = args[0], args[1], args[2]\n        else:\n            raise ValueError("arange() takes 1 to 3 positional arguments")\n        \n        data = np.arange(start, end, step)\n        device = kwargs.get(\'device\', \'cpu\')\n        dtype = kwargs.get(\'dtype\', \'int64\' if isinstance(start, int) and isinstance(end, int) and isinstance(step, int) else \'float32\')\n        return WebGPUTensor(data, device=device, dtype=dtype)\n    \n    def _randperm(self, n, **kwargs):\n        """Generate a random permutation of integers from 0 to n-1"""\n        data = np.random.permutation(n)\n        device = kwargs.get(\'device\', \'cpu\')\n        dtype = kwargs.get(\'dtype\', \'int64\')\n        return WebGPUTensor(data, device=device, dtype=dtype)\n\n    def _linspace(self, start, end, steps, **kwargs):\n        """Generate linearly spaced values"""\n        data = np.linspace(start, end, steps)\n        device = kwargs.get(\'device\', \'cpu\')\n        dtype = kwargs.get(\'dtype\', \'float32\')\n        return WebGPUTensor(data, device=device, dtype=dtype)\n\n    def _zeros_like(self, input_tensor, **kwargs):\n        """Create a tensor of zeros with the same shape as input"""\n        if isinstance(input_tensor, WebGPUTensor):\n            data = np.zeros_like(input_tensor.data)\n            device = kwargs.get(\'device\', input_tensor.device)\n            dtype = kwargs.get(\'dtype\', input_tensor.dtype)\n            return WebGPUTensor(data, device=device, dtype=dtype)\n        else:\n            data = np.zeros_like(input_tensor)\n            device = kwargs.get(\'device\', \'cpu\')\n            dtype = kwargs.get(\'dtype\', \'float32\')\n            return WebGPUTensor(data, device=device, dtype=dtype)\n\n    def _relu(self, input_tensor):\n        """ReLU activation function"""\n        if isinstance(input_tensor, WebGPUTensor):\n            result_data = np.maximum(input_tensor.data, 0)\n            result = WebGPUTensor(result_data, device="webgpu", dtype=input_tensor.dtype, requires_grad=input_tensor.requires_grad)\n            \n            if input_tensor.requires_grad:\n                def relu_backward(grad_output):\n                    if input_tensor.grad is None:\n                        input_tensor.grad = WebGPUTensor(np.zeros_like(input_tensor.data), device="webgpu", dtype=input_tensor.dtype)\n                    relu_grad = grad_output.data * (input_tensor.data > 0).astype(input_tensor.dtype)\n                    input_tensor.grad.data += relu_grad\n                \n                result._backward_fn = relu_backward\n                result._inputs = [input_tensor]\n            \n            return result\n        else:\n            return np.maximum(input_tensor, 0)\n\n    def _sqrt(self, input_tensor):\n        """Square root function"""\n        if isinstance(input_tensor, WebGPUTensor):\n            result_data = np.sqrt(input_tensor.data)\n            return WebGPUTensor(result_data, device="webgpu", dtype=input_tensor.dtype, requires_grad=input_tensor.requires_grad)\n        else:\n            return np.sqrt(input_tensor)\n\n    def _pow(self, input_tensor, exponent):\n        """Power function"""\n        if isinstance(input_tensor, WebGPUTensor):\n            result_data = np.power(input_tensor.data, exponent)\n            return WebGPUTensor(result_data, device="webgpu", dtype=input_tensor.dtype, requires_grad=input_tensor.requires_grad)\n        else:\n            return np.power(input_tensor, exponent)\n\n    def _exp(self, input_tensor):\n        """Exponential function"""\n        if isinstance(input_tensor, WebGPUTensor):\n            result_data = np.exp(input_tensor.data)\n            return WebGPUTensor(result_data, device="webgpu", dtype=input_tensor.dtype, requires_grad=input_tensor.requires_grad)\n        else:\n            return np.exp(input_tensor)\n\n    def _log(self, input_tensor):\n        """Natural logarithm function"""\n        if isinstance(input_tensor, WebGPUTensor):\n            result_data = np.log(input_tensor.data)\n            return WebGPUTensor(result_data, device="webgpu", dtype=input_tensor.dtype, requires_grad=input_tensor.requires_grad)\n        else:\n            return np.log(input_tensor)\n\n    def _mean(self, input_tensor, dim=None, keepdim=False):\n        """Mean function"""\n        if isinstance(input_tensor, WebGPUTensor):\n            if dim is None:\n                result_data = np.mean(input_tensor.data)\n                return WebGPUTensor([result_data], device="webgpu", dtype=input_tensor.dtype)\n            else:\n                result_data = np.mean(input_tensor.data, axis=dim, keepdims=keepdim)\n                return WebGPUTensor(result_data, device="webgpu", dtype=input_tensor.dtype)\n        else:\n            return np.mean(input_tensor, axis=dim, keepdims=keepdim)\n\n    def _max(self, input_tensor, dim=None, keepdim=False):\n        """Maximum function"""\n        if isinstance(input_tensor, WebGPUTensor):\n            if dim is None:\n                result_data = np.max(input_tensor.data)\n                return WebGPUTensor([result_data], device="webgpu", dtype=input_tensor.dtype)\n            else:\n                result_data = np.max(input_tensor.data, axis=dim, keepdims=keepdim)\n                return WebGPUTensor(result_data, device="webgpu", dtype=input_tensor.dtype)\n        else:\n            return np.max(input_tensor, axis=dim, keepdims=keepdim)\n\n    def _min(self, input_tensor, dim=None, keepdim=False):\n        """Minimum function"""\n        if isinstance(input_tensor, WebGPUTensor):\n            if dim is None:\n                result_data = np.min(input_tensor.data)\n                return WebGPUTensor([result_data], device="webgpu", dtype=input_tensor.dtype)\n            else:\n                result_data = np.min(input_tensor.data, axis=dim, keepdims=keepdim)\n                return WebGPUTensor(result_data, device="webgpu", dtype=input_tensor.dtype)\n        else:\n            return np.min(input_tensor, axis=dim, keepdims=keepdim)\n\n    def _transpose(self, input_tensor, dim0, dim1):\n        """Transpose function"""\n        if isinstance(input_tensor, WebGPUTensor):\n            result_data = np.swapaxes(input_tensor.data, dim0, dim1)\n            return WebGPUTensor(result_data, device="webgpu", dtype=input_tensor.dtype, requires_grad=input_tensor.requires_grad)\n        else:\n            return np.swapaxes(input_tensor, dim0, dim1)\n\n    def _cat(self, tensors, dim=0):\n        """Concatenate tensors along specified dimension"""\n        if not isinstance(tensors, (list, tuple)):\n            raise TypeError("tensors must be a list or tuple")\n\n        if len(tensors) == 0:\n            raise RuntimeError("cat expects a non-empty list of tensors")\n\n        # Convert all tensors to WebGPUTensor if needed\n        tensor_list = []\n        for tensor in tensors:\n            if isinstance(tensor, WebGPUTensor):\n                tensor_list.append(tensor.data)\n            else:\n                tensor_list.append(tensor)\n\n        # Use numpy concatenate\n        result_data = np.concatenate(tensor_list, axis=dim)\n        return WebGPUTensor(result_data, device="webgpu", dtype=tensors[0].dtype)\n\n    def _stack(self, tensors, dim=0):\n        """Stack tensors along a new dimension"""\n        if not isinstance(tensors, (list, tuple)):\n            raise TypeError("tensors must be a list or tuple")\n\n        if len(tensors) == 0:\n            raise RuntimeError("stack expects a non-empty list of tensors")\n\n        # Convert all tensors to WebGPUTensor if needed\n        tensor_list = []\n        for tensor in tensors:\n            if isinstance(tensor, WebGPUTensor):\n                tensor_list.append(tensor.data)\n            else:\n                tensor_list.append(tensor)\n\n        # Use numpy stack\n        result_data = np.stack(tensor_list, axis=dim)\n        return WebGPUTensor(result_data, device="webgpu", dtype=tensors[0].dtype)\n\n    def _std(self, input_tensor, dim=None, keepdim=False):\n        """Standard deviation function"""\n        if isinstance(input_tensor, WebGPUTensor):\n            if dim is None:\n                result_data = np.std(input_tensor.data)\n                return WebGPUTensor([result_data], device="webgpu", dtype=input_tensor.dtype)\n            else:\n                result_data = np.std(input_tensor.data, axis=dim, keepdims=keepdim)\n                return WebGPUTensor(result_data, device="webgpu", dtype=input_tensor.dtype)\n        else:\n            return np.std(input_tensor, axis=dim, keepdims=keepdim)\n\n    def _abs(self, input_tensor):\n        """Absolute value function"""\n        if isinstance(input_tensor, WebGPUTensor):\n            result_data = np.abs(input_tensor.data)\n            return WebGPUTensor(result_data, device="webgpu", dtype=input_tensor.dtype, requires_grad=input_tensor.requires_grad)\n        else:\n            return np.abs(input_tensor)\n\n    def _sin(self, input_tensor):\n        """Sine function"""\n        if isinstance(input_tensor, WebGPUTensor):\n            result_data = np.sin(input_tensor.data)\n            return WebGPUTensor(result_data, device="webgpu", dtype=input_tensor.dtype, requires_grad=input_tensor.requires_grad)\n        else:\n            return np.sin(input_tensor)\n\n    def _cos(self, input_tensor):\n        """Cosine function"""\n        if isinstance(input_tensor, WebGPUTensor):\n            result_data = np.cos(input_tensor.data)\n            return WebGPUTensor(result_data, device="webgpu", dtype=input_tensor.dtype, requires_grad=input_tensor.requires_grad)\n        else:\n            return np.cos(input_tensor)\n\n    def _clamp(self, input_tensor, min=None, max=None):\n        """Clamp function - constrain values to a range"""\n        if isinstance(input_tensor, WebGPUTensor):\n            result_data = np.clip(input_tensor.data, min, max)\n            return WebGPUTensor(result_data, device="webgpu", dtype=input_tensor.dtype, requires_grad=input_tensor.requires_grad)\n        else:\n            return np.clip(input_tensor, min, max)\n\n    def _argmax(self, input_tensor, dim=None, keepdim=False):\n        """Argmax function - indices of maximum values"""\n        if isinstance(input_tensor, WebGPUTensor):\n            if dim is None:\n                result_data = np.argmax(input_tensor.data)\n                return WebGPUTensor([result_data], device="webgpu", dtype=\'int64\')\n            else:\n                result_data = np.argmax(input_tensor.data, axis=dim)\n                if keepdim:\n                    result_data = np.expand_dims(result_data, axis=dim)\n                return WebGPUTensor(result_data, device="webgpu", dtype=\'int64\')\n        else:\n            return np.argmax(input_tensor, axis=dim)\n\n    def _no_grad(self):\n        """No gradient context manager - simplified implementation"""\n        class NoGradContext:\n            def __enter__(self):\n                return self\n\n            def __exit__(self, exc_type, exc_val, exc_tb):\n                return False\n\n        return NoGradContext()\n\nclass TorchNNL1Loss(TorchNNModule):\n    def __init__(self, reduction=\'mean\'):\n        self._parameters = {}\n        self._modules = {}\n        self._buffers = {}\n        self._non_persistent_buffers_set = set()\n        self._backward_hooks = {}\n        self._backward_pre_hooks = {}\n        self._forward_hooks = {}\n        self._forward_pre_hooks = {}\n        self._state_dict_hooks = {}\n        self._load_state_dict_pre_hooks = {}\n        self.training = True\n        self.reduction = reduction\n\n    def forward(self, input_tensor, target_tensor):\n        if isinstance(input_tensor, WebGPUTensor) and isinstance(target_tensor, WebGPUTensor):\n            diff = np.abs(input_tensor.data - target_tensor.data)\n\n            if self.reduction == \'mean\':\n                loss_value = np.mean(diff)\n            elif self.reduction == \'sum\':\n                loss_value = np.sum(diff)\n            else:  # \'none\'\n                loss_value = diff\n\n            return WebGPUTensor([loss_value] if np.isscalar(loss_value) else loss_value,\n                             device="webgpu", dtype=input_tensor.dtype)\n        else:\n            raise TypeError("Both input and target must be WebGPUTensor")\n\n\nclass TorchNN:\n    def __init__(self):\n        self.functional = TorchNNFunctional()\n        self.Linear = TorchNNLinear\n        self.Module = TorchNNModule\n        self.ReLU = TorchNNReLU\n        self.MSELoss = TorchNNMSELoss\n        self.L1Loss = TorchNNL1Loss\n\n# Global cleanup function to prevent state persistence issues\ndef _cleanup_global_state():\n    """Clean up global tensor state to prevent persistence issues between executions"""\n    import gc\n    # Force garbage collection to clean up circular references\n    gc.collect()\n\n# Install in global namespace\ntorch = TorchModule()\nsys.modules[\'torch\'] = torch\nsys.modules[\'torch.nn\'] = torch.nn\nsys.modules[\'torch.nn.functional\'] = torch.nn.functional\nsys.modules[\'torch.linalg\'] = torch.linalg\n\n# Clean up any existing state to prevent issues\n_cleanup_global_state()\n'}function r(e){if(!e||"string"!=typeof e)throw new Error("Invalid polyfill code provided");if(e.length>1e6)throw new Error("Polyfill code too large");return!0}t.d(n,{EH:()=>r,pH:()=>s})}}]);